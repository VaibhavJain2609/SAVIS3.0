/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./dist/en/oneMean/oneMeanEntry.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/en/oneMean/oneMean.js":
/*!************************************!*\
  !*** ./dist/en/oneMean/oneMean.js ***!
  \************************************/
/*! exports provided: OneMean */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OneMean\", function() { return OneMean; });\n/* harmony import */ var _util_csv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/csv.js */ \"./dist/en/util/csv.js\");\n/* harmony import */ var _util_stackeddotchart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/stackeddotchart.js */ \"./dist/en/util/stackeddotchart.js\");\n/* harmony import */ var _util_sampling_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/sampling.js */ \"./dist/en/util/sampling.js\");\n/* harmony import */ var _util_math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/math.js */ \"./dist/en/util/math.js\");\n/* harmony import */ var _util_translate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/translate.js */ \"./dist/en/util/translate.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar OneMean =\n/*#__PURE__*/\nfunction () {\n  function OneMean(OneMeanDiv) {\n    var _this = this;\n\n    _classCallCheck(this, OneMean);\n\n    this.shiftMean = 0;\n    this.mulFactor = 0;\n    this.populationData = [];\n    this.populationMean = undefined;\n    this.originalData = [];\n    this.mostRecentDraw = [];\n    this.sampleMeans = [];\n    this.sampleSize = undefined;\n    this.translationData = undefined;\n    this.tailDiection = null;\n    this.translationData = _util_translate_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].oneMean;\n    this.sampleData = {\n      // has to hardcode if not using server\n      \"Select Sample Data\": null,\n      Sample1: \"../sampleData/sample1.csv\",\n      Sample2: \"../sampleData/sample2.csv\"\n    };\n    this.ele = {\n      csvTextArea: OneMeanDiv.querySelector(\"#csv-input\"),\n      loadDataBtn: OneMeanDiv.querySelector(\"#load-data-btn\"),\n      shiftMeanInput: OneMeanDiv.querySelector(\"#shiftMeanInput\"),\n      originalDataDisplay: OneMeanDiv.querySelector(\"#original-data-display\"),\n      populationDataDisplay: OneMeanDiv.querySelector(\"#population-data-display\"),\n      recentSampleDisplay: OneMeanDiv.querySelector(\"#most-recent-sample-display\"),\n      sampleMeansDisplay: OneMeanDiv.querySelector(\"#samples-mean-display\"),\n      sampleMean: OneMeanDiv.querySelector(\"#sample-mean\"),\n      samplesMean: OneMeanDiv.querySelector(\"#samples-mean\"),\n      originalMean: OneMeanDiv.querySelector(\"#original-mean\"),\n      polulationMean: OneMeanDiv.querySelector(\"#population-mean\"),\n      mulFactorDisplay: OneMeanDiv.querySelector(\"#mul-factor-display\"),\n      mulFactorSlider: OneMeanDiv.querySelector(\"#mul-factor\"),\n      runSimBtn: OneMeanDiv.querySelector(\"#run-sim-btn\"),\n      sampleSizeInput: OneMeanDiv.querySelector(\"#sample-size\"),\n      noOfSampleInput: OneMeanDiv.querySelector(\"#no-of-sample\"),\n      tailValueInput: OneMeanDiv.querySelector(\"#tailValue\"),\n      tailDirectionInput: OneMeanDiv.querySelector(\"#tailDirection\"),\n      totalSelectedSamplesDisplay: OneMeanDiv.querySelector(\"#total-selected-samples\"),\n      totalSamplesDisplay: OneMeanDiv.querySelector(\"#total-samples\"),\n      proportionDisplay: OneMeanDiv.querySelector(\"#proportion\"),\n      oneMeanDiv: OneMeanDiv,\n      runSimErrorMsg: OneMeanDiv.querySelector(\"#run-sim-error-msg\"),\n      sampleDataDropDown: OneMeanDiv.querySelector(\"#sample-data\"),\n      resetBtn: OneMeanDiv.querySelector(\"#reset-btn\"),\n      translationData: OneMeanDiv.querySelector(\"#translation-data\"),\n      originalStd: OneMeanDiv.querySelector(\"#original-std\"),\n      sampleMeansStd: OneMeanDiv.querySelector(\"#samplemeans-std\"),\n      populationStd: OneMeanDiv.querySelector(\"#population-std\"),\n      uploadbtn: OneMeanDiv.querySelector(\"#upload-btn\"),\n      fileInput: OneMeanDiv.querySelector(\"#fileInput\"),\n      size: OneMeanDiv.querySelector(\"#originalsize\")\n    }; // this.readTranlationData();\n\n    Object(_util_csv_js__WEBPACK_IMPORTED_MODULE_0__[\"enableUploadDataFile\"])(this.ele.uploadbtn, this.ele.fileInput, this.ele.csvTextArea);\n    this.datasets = [{\n      label: this.translationData.original,\n      backgroundColor: \"orange\",\n      data: []\n    }, {\n      label: this.translationData.hypotheticalPopulation,\n      backgroundColor: \"orange\",\n      data: []\n    }, {\n      label: this.translationData.mostRecentDraw,\n      backgroundColor: \"blue\",\n      data: []\n    }, [{\n      label: this.translationData.sampleMeans,\n      backgroundColor: \"green\",\n      data: []\n    }, {\n      label: \"N/A\",\n      backgroundColor: \"red\",\n      data: []\n    }]];\n    this.dataChart1 = new _util_stackeddotchart_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](OneMeanDiv.querySelector(\"#original-data-chart\"), [this.datasets[0]]);\n    this.dataChart2 = new _util_stackeddotchart_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](OneMeanDiv.querySelector(\"#population-data-chart\"), [this.datasets[1]]);\n    this.dataChart2.setAnimationDuration(0);\n    this.dataChart3 = new _util_stackeddotchart_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](OneMeanDiv.querySelector(\"#sample-data-chart\"), [this.datasets[2]]);\n    this.dataChart3.setAnimationDuration(0);\n    this.dataChart4 = new _util_stackeddotchart_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](OneMeanDiv.querySelector(\"#statistic-data-chart\"), this.datasets[3]);\n    this.dataChart4.setAnimationDuration(0);\n    this.dataName = {\n      orginalData: \"orginalData\",\n      populationData: \"populationData\",\n      mostRecentDraw: \"mostRecentDraw\",\n      sampleMeans: \"sampleMeans\"\n    };\n\n    this.loadEventListener = function () {\n      _this.ele.loadDataBtn.addEventListener(\"click\", function (e) {\n        _this.originalData = Object(_util_csv_js__WEBPACK_IMPORTED_MODULE_0__[\"parseCSVtoSingleArray\"])(_this.ele.csvTextArea.value);\n\n        _this.updateData(_this.dataName.orginalData);\n\n        _this.shiftMean = 0;\n        _this.mulFactor = 0;\n        _this.ele.size.innerText = _this.originalData.length;\n\n        _this.clearResult();\n\n        _this.updatedPopulationData(_this.originalData, _this.shiftMean, _this.mulFactor);\n\n        e.preventDefault();\n      });\n\n      Object(_util_csv_js__WEBPACK_IMPORTED_MODULE_0__[\"dropTextFileOnTextArea\"])(_this.ele.csvTextArea);\n\n      _this.sampleListListener();\n\n      _this.shiftMeanListener();\n\n      _this.mulFactorListener();\n\n      _this.resetBtnListener();\n\n      _this.ele.runSimBtn.addEventListener(\"click\", function (e) {\n        var newSampleSize = Number(_this.ele.sampleSizeInput.value);\n        var noOfSamples = Number(_this.ele.noOfSampleInput.value);\n\n        _this.runSim(newSampleSize, noOfSamples);\n\n        e.preventDefault();\n      });\n\n      _this.ele.tailDirectionInput.addEventListener(\"change\", function (e) {\n        if (_this.sampleMeans.length) _this.updateData(_this.dataName.sampleMeans);\n      });\n\n      _this.ele.tailValueInput.addEventListener(\"input\", function (e) {\n        if (_this.sampleMeans.length) _this.updateData(_this.dataName.sampleMeans);\n      });\n\n      _this.ele.oneMeanDiv.addEventListener(\"click\", function (e) {\n        if (e.target.className === \"toggle-box\") {\n          var div = e.target.parentElement.nextElementSibling;\n          div.style.display = div.style.display === \"none\" ? \"flex\" : \"none\";\n        }\n      });\n    };\n\n    this.loadSampleDataList();\n    this.loadEventListener();\n  }\n\n  _createClass(OneMean, [{\n    key: \"loadSampleDataList\",\n    value: function loadSampleDataList() {\n      var _this2 = this;\n\n      Object.keys(this.sampleData).forEach(function (x) {\n        var option = document.createElement(\"option\", {});\n        option.setAttribute(\"value\", x);\n        option.innerText = x;\n\n        _this2.ele.sampleDataDropDown.appendChild(option);\n      });\n    }\n  }, {\n    key: \"runSim\",\n    value: function runSim(sampleSize, noOfSample) {\n      var _this3 = this;\n\n      // if (this.populationData.length === 0) return;\n      var newMeanSamples = [];\n\n      try {\n        if (!this.populationData.length) throw this.translationData.errorNoPopulation;\n\n        for (var i = 0; i < noOfSample; i++) {\n          var _randomSubset = Object(_util_sampling_js__WEBPACK_IMPORTED_MODULE_2__[\"randomSubset\"])(this.populationData, sampleSize),\n              chosen = _randomSubset.chosen,\n              unchoosen = _randomSubset.unchoosen;\n\n          var roundedMean = _util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"roundToPlaces\"](_util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"mean\"](chosen.map(function (x) {\n            return x.value;\n          })), 3);\n          newMeanSamples.push(roundedMean);\n          if (i === noOfSample - 1) this.mostRecentDraw = chosen;\n        }\n\n        if (this.sampleSize !== sampleSize) {\n          this.sampleSize = sampleSize;\n          this.sampleMeans = newMeanSamples;\n        } else {\n          this.sampleMeans = this.sampleMeans.concat(newMeanSamples);\n        }\n      } catch (err) {\n        var errMsg = \"ERROR\\n\";\n        if (this.populationData.length) errMsg += this.translationData.errorNotEnoughElements;else errMsg += this.translationData.errorNoPopulation;\n        this.ele.runSimErrorMsg.innerText = errMsg;\n        setTimeout(function () {\n          _this3.ele.runSimErrorMsg.innerText = \"\";\n        }, 2000);\n      }\n\n      this.updateData(this.dataName.mostRecentDraw);\n      this.updateData(this.dataName.sampleMeans);\n    }\n  }, {\n    key: \"resetBtnListener\",\n    value: function resetBtnListener() {\n      var _this4 = this;\n\n      this.ele.resetBtn.addEventListener(\"click\", function (e) {\n        _this4.clearResult();\n\n        _this4.ele.csvTextArea.value = \"\";\n        _this4.originalData = [];\n\n        _this4.updateData(_this4.dataName.orginalData);\n\n        _this4.shiftMean = 0;\n        _this4.mulFactor = 0;\n        _this4.ele.size.innerText = 0;\n\n        _this4.clearResult();\n\n        _this4.ele.sampleDataDropDown.selectedIndex = 0;\n\n        _this4.updatedPopulationData(_this4.originalData, _this4.shiftMean, _this4.mulFactor);\n\n        e.preventDefault();\n      });\n    }\n  }, {\n    key: \"sampleListListener\",\n    value: function sampleListListener() {\n      var _this5 = this;\n\n      this.ele.sampleDataDropDown.addEventListener(\"change\", function () {\n        var sampleName = _this5.ele.sampleDataDropDown.value;\n\n        if (sampleName != _this5.translationData.selectData) {\n          Object(_util_csv_js__WEBPACK_IMPORTED_MODULE_0__[\"readLocalFile\"])(_this5.sampleData[sampleName]).then(function (text) {\n            return _this5.ele.csvTextArea.value = text;\n          });\n        } else _this5.ele.csvTextArea.value = \"\";\n      });\n    }\n  }, {\n    key: \"shiftMeanListener\",\n    value: function shiftMeanListener() {\n      var _this6 = this;\n\n      this.ele.shiftMeanInput.addEventListener(\"input\", function (e) {\n        _this6.updatedPopulationData(_this6.originalData, Number(e.target.value) || 0, _this6.mulFactor);\n\n        _this6.clearResult();\n      });\n    }\n  }, {\n    key: \"mulFactorListener\",\n    value: function mulFactorListener() {\n      var _this7 = this;\n\n      this.ele.mulFactorSlider.addEventListener(\"change\", function (e) {\n        var mulFactor = Number(e.target.value);\n        _this7.ele.mulFactorDisplay.innerText = mulFactor;\n      });\n      this.ele.mulFactorSlider.addEventListener(\"input\", function (e) {\n        var mulFactor = Number(e.target.value);\n\n        _this7.updatedPopulationData(_this7.originalData, _this7.shiftMean, mulFactor);\n\n        _this7.ele.mulFactorDisplay.innerText = mulFactor;\n\n        _this7.clearResult();\n      });\n    }\n  }, {\n    key: \"updatedPopulationData\",\n    value: function updatedPopulationData(originalData, shift, mulFactor) {\n      var _this8 = this;\n\n      this.shiftMean = shift;\n      this.ele.shiftMeanInput.value = shift;\n      this.mulFactor = mulFactor;\n      this.populationData = [];\n      originalData.forEach(function (x) {\n        for (var i = 0; i <= mulFactor; i++) {\n          _this8.populationData.push({\n            id: (x.id - 1) * (mulFactor + 1) + i + 1,\n            value: _util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"roundToPlaces\"](x.value + shift, 4)\n          });\n        }\n      });\n      this.populationMean = _util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"roundToPlaces\"](_util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"mean\"](this.populationData.map(function (x) {\n        return x.value;\n      })), 2);\n      this.ele.populationStd.innerText = _util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"roundToPlaces\"](_util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"stddev\"](this.populationData.map(function (x) {\n        return x.value;\n      })), 2);\n      this.updateData(this.dataName.populationData);\n    }\n  }, {\n    key: \"clearResult\",\n    value: function clearResult() {\n      this.ele.shiftMeanInput.value = this.shiftMean;\n      this.ele.mulFactorSlider.value = this.mulFactor;\n      this.ele.mulFactorDisplay.innerText = this.mulFactor;\n      this.mostRecentDraw = [];\n      this.sampleMeans = [];\n      this.tailDiection = null;\n      this.ele.tailDirectionInput.value = this.tailDiection;\n      this.updateData(this.dataName.mostRecentDraw);\n      this.updateData(this.dataName.sampleMeans);\n    } //update chart, mean and textarea based on the dataName\n\n  }, {\n    key: \"updateData\",\n    value: function updateData(dataName) {\n      var chart, data, meanEle, key, textAreaEle;\n\n      if (dataName === this.dataName.orginalData) {\n        chart = this.dataChart1;\n        data = this.originalData;\n        meanEle = this.ele.originalMean;\n        textAreaEle = this.ele.originalDataDisplay;\n        this.ele.originalStd.innerText = _util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"roundToPlaces\"](_util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"sampleStddev\"](data.map(function (x) {\n          return x.value;\n        })), 2);\n      } else if (dataName === this.dataName.populationData) {\n        chart = this.dataChart2;\n        data = this.populationData;\n        meanEle = this.ele.polulationMean;\n        textAreaEle = this.ele.populationDataDisplay;\n      } else if (dataName === this.dataName.mostRecentDraw) {\n        chart = this.dataChart3;\n        data = this.mostRecentDraw;\n        meanEle = this.ele.sampleMean;\n        textAreaEle = this.ele.recentSampleDisplay;\n      } else {\n        chart = this.dataChart4;\n        data = this.sampleMeans;\n        meanEle = this.ele.samplesMean;\n        textAreaEle = this.ele.sampleMeansDisplay;\n        this.ele.sampleMeansStd.innerText = _util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"roundToPlaces\"](_util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"stddev\"](data), 2);\n      } // update chart\n\n\n      var valuesArr = null;\n      var pointRadius = 6;\n\n      if (data.length) {\n        if (dataName !== this.dataName.sampleMeans) {\n          valuesArr = data.map(function (x) {\n            return x.value;\n          });\n          chart.setDataFromRaw([valuesArr]);\n        } else {\n          valuesArr = data;\n          var tailDirection = this.ele.tailDirectionInput.value;\n          var tailInput = Number(this.ele.tailValueInput.value);\n          var _mean = this.populationMean;\n\n          var _splitByPredicate = Object(_util_sampling_js__WEBPACK_IMPORTED_MODULE_2__[\"splitByPredicate\"])(valuesArr, this.predicateForTail(tailDirection, tailInput, _mean)),\n              chosen = _splitByPredicate.chosen,\n              unchosen = _splitByPredicate.unchosen; //update statistic output\n\n\n          this.updateStatistic(chosen.length, unchosen.length);\n          this.updateSampleMeansChartLabels(tailDirection, tailInput, _mean);\n          chart.setDataFromRaw([unchosen, chosen]);\n          pointRadius = 2;\n        } // if (data.length > 500) chart.setAnimationDuration(0);\n        // else chart.setAnimationDuration(1000);\n\n\n        chart.changeDotAppearance(pointRadius, undefined);\n        var min = _util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"minInArray\"](valuesArr);\n        var max = _util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"maxInArray\"](valuesArr);\n        chart.setScale(min, max);\n      } else {\n        chart.clear();\n      }\n\n      chart.scaleToStackDots();\n      chart.chart.update(); //update mean output\n\n      var mean = data.length ? _util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"roundToPlaces\"](_util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"mean\"](valuesArr), 2) : this.translationData.noData;\n      meanEle.innerText = mean;\n\n      if (dataName === this.dataName.orginalData && !isNaN(mean)) {\n        this.ele.tailValueInput.value = mean;\n      } // update text area output\n\n\n      if (dataName !== this.dataName.sampleMeans) {\n        textAreaEle.value = data.reduce(function (acc, x) {\n          return acc + \"\".concat(x.id).padEnd(8, ' ') + \"\".concat(x.value, \"\\n\");\n        }, \"\".concat(this.translationData.id).padEnd(8, ' ') + \"\".concat(this.translationData.value, \"\\n\"));\n      } else {\n        textAreaEle.value = data.reduce(function (acc, x, index) {\n          return acc + \"\".concat(index + 1).padEnd(8, ' ') + \"\".concat(x, \"\\n\");\n        }, \"\".concat(this.translationData.sampleNo).padEnd(8, ' ') + \"\".concat(this.translationData.mean2, \"\\n\"));\n      }\n    }\n  }, {\n    key: \"updateStatistic\",\n    value: function updateStatistic(totalChosen, totalUnchosen) {\n      var totalSamples = totalChosen + totalUnchosen;\n      var proportion = _util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"roundToPlaces\"](totalChosen / totalSamples, 5);\n      this.ele.totalSelectedSamplesDisplay.innerText = totalChosen;\n      this.ele.totalSamplesDisplay.innerText = totalSamples;\n      this.ele.proportionDisplay.innerText = \" \".concat(totalChosen, \" / \").concat(totalSamples, \" = \").concat(proportion);\n    }\n  }, {\n    key: \"predicateForTail\",\n    value: function predicateForTail(tailDirection, tailInput, mean) {\n      if (tailDirection === \"null\") {\n        return null;\n      } else if (tailDirection === \"oneTailRight\") {\n        return function (x) {\n          return x >= tailInput;\n        };\n      } else if (tailDirection === \"oneTailLeft\") {\n        return function (x) {\n          return x <= tailInput;\n        };\n      } else {\n        var distance = _util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"roundToPlaces\"](Math.abs(mean - tailInput), 2);\n        return function (x) {\n          return x <= mean - distance || x >= mean + distance;\n        };\n      }\n    }\n  }, {\n    key: \"updateSampleMeansChartLabels\",\n    value: function updateSampleMeansChartLabels(tailDirection, tailInput, mean) {\n      var sampleName = this.translationData.sampleMeans;\n\n      if (tailDirection === \"null\") {\n        this.dataChart4.updateLabelName(0, \"\".concat(sampleName));\n        this.dataChart4.updateLabelName(1, \"N/A\");\n      } else if (tailDirection === \"oneTailRight\") {\n        this.dataChart4.updateLabelName(0, \"\".concat(sampleName, \" < \").concat(tailInput));\n        this.dataChart4.updateLabelName(1, \"\".concat(sampleName, \" >= \").concat(tailInput));\n      } else if (tailDirection === \"oneTailLeft\") {\n        this.dataChart4.updateLabelName(0, \"\".concat(sampleName, \" > \").concat(tailInput));\n        this.dataChart4.updateLabelName(1, \"\".concat(sampleName, \" <= \").concat(tailInput));\n      } else {\n        var distance = mean - tailInput;\n        var left = _util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"roundToPlaces\"](mean - distance, 2);\n        var right = _util_math_js__WEBPACK_IMPORTED_MODULE_3__[\"roundToPlaces\"](mean + distance, 2);\n        this.dataChart4.updateLabelName(0, \"\".concat(left, \" < \").concat(sampleName, \" < \").concat(right));\n        this.dataChart4.updateLabelName(1, \"\".concat(sampleName, \" <= \").concat(left, \" or \").concat(sampleName, \" >= \").concat(right));\n      }\n    }\n  }]);\n\n  return OneMean;\n}();\n\n//# sourceURL=webpack:///./dist/en/oneMean/oneMean.js?");

/***/ }),

/***/ "./dist/en/oneMean/oneMeanEntry.js":
/*!*****************************************!*\
  !*** ./dist/en/oneMean/oneMeanEntry.js ***!
  \*****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _oneMean_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./oneMean.js */ \"./dist/en/oneMean/oneMean.js\");\n\nwindow.oneMean = new _oneMean_js__WEBPACK_IMPORTED_MODULE_0__[\"OneMean\"](document.getElementById('one-mean'));\n\n//# sourceURL=webpack:///./dist/en/oneMean/oneMeanEntry.js?");

/***/ }),

/***/ "./dist/en/util/csv.js":
/*!*****************************!*\
  !*** ./dist/en/util/csv.js ***!
  \*****************************/
/*! exports provided: dropTextFileOnTextArea, enableUploadDataFile, parseCsvVariableByCol, parseCSVtoSingleArray, readLocalFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dropTextFileOnTextArea\", function() { return dropTextFileOnTextArea; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableUploadDataFile\", function() { return enableUploadDataFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseCsvVariableByCol\", function() { return parseCsvVariableByCol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseCSVtoSingleArray\", function() { return parseCSVtoSingleArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"readLocalFile\", function() { return readLocalFile; });\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction dropTextFileOnTextArea(textAreaElement) {\n  textAreaElement.addEventListener(\"dragover\", function () {\n    textAreaElement.classList.add(\"dragover\");\n  });\n  textAreaElement.addEventListener(\"dragleave\", function () {\n    textAreaElement.classList.remove(\"dragover\");\n  });\n  textAreaElement.addEventListener(\"drop\", function (e) {\n    textAreaElement.classList.remove(\"dragover\");\n    var file = e.dataTransfer.files[0];\n    var reader = new FileReader();\n\n    reader.onload = function (event) {\n      textAreaElement.value = event.target.result;\n    };\n\n    reader.readAsText(file);\n    e.preventDefault();\n  });\n}\nfunction enableUploadDataFile(uploadButton, fileInput, textAreaElement) {\n  uploadButton.addEventListener('click', function (event) {\n    fileInput.click();\n    event.preventDefault();\n  });\n  fileInput.addEventListener('change', function (event) {\n    var file = fileInput.files[0];\n    var reader = new FileReader();\n\n    reader.onload = function (event) {\n      textAreaElement.value = event.target.result;\n    };\n\n    reader.readAsText(file);\n    event.preventDefault();\n  });\n}\n/**\n * rawData format:\n * a,b,c\n * 1,2,3\n * 15.2,54.3,55.3\n *\n * return {\n * a: [1, 15.2]\n * b: [2, 54.3]\n * c: [3, 55.3]\n * }\n *\n * throw error if data not match\n */\n\nfunction parseCsvVariableByCol(rawData) {\n  var columns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  var _rawData$split = rawData.split(/[\\r\\n]+/),\n      _rawData$split2 = _toArray(_rawData$split),\n      Header = _rawData$split2[0],\n      data = _rawData$split2.slice(1);\n\n  var varNames = !columns ? Header.split(/[\\t,]/).map(function (x) {\n    return x.trim();\n  }) : columns;\n  var res = varNames.reduce(function (acc, x) {\n    return _objectSpread({}, acc, _defineProperty({}, x, []));\n  }, {});\n\n  if (columns) {\n    data.unshift(Header);\n  }\n\n  data.forEach(function (row) {\n    var nums = row.match(/(\\d+(\\.\\d+)?)|-(\\d+(\\.\\d+)?)/g);\n    varNames.forEach(function (x, index) {\n      if (nums && nums.length === varNames.length) res[x].push(Number(nums[index]));\n    });\n  });\n  return res;\n}\nfunction parseCSVtoSingleArray(rawData) {\n  var numRegex = /(\\d+(\\.\\d+)?)/;\n  return rawData.split(/[\\r\\n]+/).filter(function (x) {\n    return numRegex.test(x);\n  }).map(function (x, index) {\n    return {\n      id: index + 1,\n      value: Number(x.match(numRegex)[0])\n    };\n  });\n} //return promise\n\nfunction readLocalFile(filePath) {\n  return fetch(filePath).then(function (r) {\n    return r.text();\n  });\n}\n\n//# sourceURL=webpack:///./dist/en/util/csv.js?");

/***/ }),

/***/ "./dist/en/util/math.js":
/*!******************************!*\
  !*** ./dist/en/util/math.js ***!
  \******************************/
/*! exports provided: mean, stddev, sampleStddev, variance, roundToPlaces, minInArray, maxInArray, countWhere, z_value, z_score_alpha_2, getOneMeanConfidenceInterval, getCutOffInterval */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mean\", function() { return mean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stddev\", function() { return stddev; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sampleStddev\", function() { return sampleStddev; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"variance\", function() { return variance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"roundToPlaces\", function() { return roundToPlaces; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"minInArray\", function() { return minInArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"maxInArray\", function() { return maxInArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"countWhere\", function() { return countWhere; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"z_value\", function() { return z_value; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"z_score_alpha_2\", function() { return z_score_alpha_2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getOneMeanConfidenceInterval\", function() { return getOneMeanConfidenceInterval; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCutOffInterval\", function() { return getCutOffInterval; });\nfunction mean(itr) {\n  var sum = 0;\n  var count = 0;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = itr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var item = _step.value;\n      sum += item;\n      count += 1;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return sum / count;\n} // Population Standard Deviation\n\nfunction stddev(itr) {\n  return Math.sqrt(variance(itr));\n} // Sample Standard Deviation\n\nfunction sampleStddev(itr) {\n  var n = itr.length;\n  if (n <= 1) return NaN;\n  var sampleMean = mean(itr);\n  var devSquare = itr.reduce(function (acc, x) {\n    return (x - sampleMean) * (x - sampleMean) + acc;\n  }, 0);\n  return Math.sqrt(devSquare / (n - 1));\n}\nfunction variance(itr) {\n  var sum = 0;\n  var count = 0;\n  var sumOfSquares = 0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = itr[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var item = _step2.value;\n      sum += item;\n      sumOfSquares += item * item;\n      count += 1;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  var mean = sum / count; // variance = sum(X^2) / N - mean(X)^2\n\n  return sumOfSquares / count - mean * mean;\n}\nfunction roundToPlaces(value, places) {\n  var pow10 = Math.pow(10, places);\n  return Math.round(value * pow10) / pow10;\n}\n/**\n * js Math.min and Math.max will cause stack overflow for large array size\n * @param {numnber array} arr\n */\n\nfunction minInArray(arr) {\n  if (!arr) return undefined;\n  return arr.reduce(function (acc, x) {\n    return acc < x ? acc : x;\n  }, arr[0]);\n}\nfunction maxInArray(arr) {\n  if (!arr) return undefined;\n  return arr.reduce(function (acc, x) {\n    return acc > x ? acc : x;\n  }, arr[0]);\n}\n/**\n * Counts items of iterable meeting predicate\n *\n * @param itr iterable\n * @param p   predicate\n */\n\nfunction countWhere(itr, p) {\n  if (itr === undefined || p === undefined) {\n    throw new Error(\"Missing parameter\");\n  }\n\n  var res = 0;\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = itr[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var item = _step3.value;\n\n      if (p(item)) {\n        res += 1;\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return res;\n}\nfunction z_value(probability) {\n  var Z_MAX = 6;\n  var p = probability;\n  var Z_EPSILON = 0.000001;\n  /* Accuracy of z approximation */\n\n  var minz = -Z_MAX;\n  var maxz = Z_MAX;\n  var zval = 0.0;\n  var pval;\n  if (p < 0.0) p = 0.0;\n  if (p > 1.0) p = 1.0;\n\n  while (maxz - minz > Z_EPSILON) {\n    pval = poz(zval);\n\n    if (pval > p) {\n      maxz = zval;\n    } else {\n      minz = zval;\n    }\n\n    zval = (maxz + minz) * 0.5;\n  }\n\n  return zval;\n}\nfunction z_score_alpha_2(confidenceLevel) {\n  var alpha = confidenceLevel / 100.0;\n  var alpha_over_2 = (1 - alpha) / 2.0;\n  return Math.abs(roundToPlaces(z_value(alpha_over_2), 2));\n}\nfunction getOneMeanConfidenceInterval(confidenceLevel, sampleMean, populationStd, sampleSize) {\n  var z_alpha_2 = z_score_alpha_2(confidenceLevel);\n  var sampleStd = (populationStd + 0.0) / Math.sqrt(sampleSize);\n  var leftBound = sampleMean - z_alpha_2 * sampleStd;\n  var rightBound = sampleMean + z_alpha_2 * sampleStd;\n  return [leftBound, rightBound];\n}\nfunction getCutOffInterval(confidenceLevel, totalSize) {\n  confidenceLevel = confidenceLevel / 100.0;\n  var alpha2 = (1 - confidenceLevel) / 2.0;\n  var lowerBound = alpha2 * totalSize;\n  var upperBound = totalSize - alpha2 * totalSize;\n  lowerBound = Math.floor(lowerBound);\n  upperBound = Math.floor(upperBound);\n  return [lowerBound, upperBound];\n}\n\nfunction poz(z) {\n  // O(1)\n  var Z_MAX = 6;\n  var y, x, w;\n\n  if (z == 0.0) {\n    x = 0.0;\n  } else {\n    y = 0.5 * Math.abs(z);\n\n    if (y > Z_MAX * 0.5) {\n      x = 1.0;\n    } else if (y < 1.0) {\n      w = y * y;\n      x = ((((((((0.000124818987 * w - 0.001075204047) * w + 0.005198775019) * w - 0.019198292004) * w + 0.059054035642) * w - 0.151968751364) * w + 0.319152932694) * w - 0.531923007300) * w + 0.797884560593) * y * 2.0;\n    } else {\n      y -= 2.0;\n      x = (((((((((((((-0.000045255659 * y + 0.000152529290) * y - 0.000019538132) * y - 0.000676904986) * y + 0.001390604284) * y - 0.000794620820) * y - 0.002034254874) * y + 0.006549791214) * y - 0.010557625006) * y + 0.011630447319) * y - 0.009279453341) * y + 0.005353579108) * y - 0.002141268741) * y + 0.000535310849) * y + 0.999936657524;\n    }\n  }\n\n  return z > 0.0 ? (x + 1.0) * 0.5 : (1.0 - x) * 0.5;\n}\n\n//# sourceURL=webpack:///./dist/en/util/math.js?");

/***/ }),

/***/ "./dist/en/util/sampling.js":
/*!**********************************!*\
  !*** ./dist/en/util/sampling.js ***!
  \**********************************/
/*! exports provided: randomInt, shuffle, randomSubset, splitUsing, splitByPredicate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randomInt\", function() { return randomInt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shuffle\", function() { return shuffle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randomSubset\", function() { return randomSubset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitUsing\", function() { return splitUsing; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitByPredicate\", function() { return splitByPredicate; });\n/* harmony import */ var _util_translate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/translate.js */ \"./dist/en/util/translate.js\");\n\nfunction randomInt(from, to) {\n  return Math.floor((to - from) * Math.random()) + from;\n}\n/*\n * Returns a new array that contains shuffled elements of the original array.\n */\n\nfunction shuffle(arr) {\n  var clone = arr.concat([]);\n\n  function swap(i, j) {\n    var tmp = clone[i];\n    clone[i] = clone[j];\n    clone[j] = tmp;\n  }\n\n  for (var i = 0; i < arr.length; i++) {\n    var swapWith = randomInt(i, arr.length);\n    swap(i, swapWith);\n  }\n\n  return clone;\n}\n/**\n * Returns a two arrays: one array containing `n` pseudo-randomly chosen\n * elements from iterable `itr`, and another array containing all the\n * `unchosen` items. The order of the returned arrays are not guaranteed to be\n * random. Throws an exception if n > length(itr).\n */\n\nfunction randomSubset(itr, n) {\n  var result = Array(n);\n  var unchosen = [];\n  var seen = 0;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = itr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var item = _step.value;\n\n      // Take first `n` items\n      if (seen < n) {\n        result[seen] = item;\n      } // Each subsequent item has some chance of being pulled in\n      else if (Math.random() < n / (seen + 1)) {\n          // Randomly decide who gets the boot\n          var replaceIdx = randomInt(0, n);\n          unchosen.push(result[replaceIdx]);\n          result[replaceIdx] = item;\n        } else {\n          unchosen.push(item);\n        }\n\n      seen += 1;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (seen < n) {\n    throw new Error(\"not enought elements\");\n  }\n\n  return {\n    chosen: result,\n    unchosen: unchosen\n  };\n}\n/**\n * fn is a predicate function\n * return two arrays, one is when fn is true, one is when fn is false\n * if fn is null, all elements will be unchosen\n */\n\nfunction splitUsing(itr, callback) {\n  var chosen = [];\n  var unchosen = [];\n  itr.forEach(function (obj, index) {\n    if (callback(obj, index)) {\n      chosen.push(obj);\n    } else {\n      unchosen.push(obj);\n    }\n  });\n  return [chosen, unchosen];\n}\nfunction splitByPredicate(itr, fn) {\n  var chosen = [];\n  var unchosen = [];\n  if (fn === null) unchosen = itr;else {\n    itr.forEach(function (x) {\n      if (fn(x)) chosen.push(x);else unchosen.push(x);\n    });\n  }\n  return {\n    chosen: chosen,\n    unchosen: unchosen\n  };\n}\n\n//# sourceURL=webpack:///./dist/en/util/sampling.js?");

/***/ }),

/***/ "./dist/en/util/stackeddotchart.js":
/*!*****************************************!*\
  !*** ./dist/en/util/stackeddotchart.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return StackedDotChart; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// TODO(matthewmerrill): don't CDN\n//import Chart from \"chart.js\";\n\n/*\n\n\n*/\nvar StackedDotChart =\n/*#__PURE__*/\nfunction () {\n  function StackedDotChart(domElement, datasets, options) {\n    _classCallCheck(this, StackedDotChart);\n\n    this.domElement = domElement;\n    this.datasets = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = datasets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var dataset = _step.value;\n        this.datasets.push(Object.assign({}, dataset, {\n          pointRadius: 8\n        }));\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    this.chart = new Chart(domElement, {\n      type: \"scatter\",\n      data: {\n        datasets: this.datasets\n      },\n      options: {\n        scales: {\n          //xAxes: [{ ticks: { beginAtZero: true, }}],\n          yAxes: [{\n            ticks: {\n              min: 1,\n              stepSize: 1\n            }\n          }]\n        },\n        responsive: true,\n        maintainAspectRatio: false\n      }\n    });\n    options = options || {};\n    this.options = {\n      autoBuckets: options.autoBuckets !== undefined ? options.autoBuckets : true,\n      bucketWidth: options.bucketWidth\n    };\n  }\n\n  _createClass(StackedDotChart, [{\n    key: \"round\",\n    value: function round(x, bucketSize) {\n      if (bucketSize == undefined) {\n        if (this.options.autoBuckets) {\n          var scale = this.chart.scales['x-axis-1'];\n          var inScaleWidth = scale.options.ticks.max - scale.options.ticks.min;\n          var chartWidth = this.chart.width;\n          var pointRadius = this.chart.data.datasets[0].pointRadius;\n          bucketSize = 2 * pointRadius * (inScaleWidth / chartWidth);\n        } else if (this.options.bucketWidth) {\n          bucketSize = this.bucketWidth;\n        }\n      }\n\n      if (bucketSize) {\n        var r = Math.floor(x / bucketSize) * bucketSize;\n        return r;\n      } else {\n        return x;\n      }\n    }\n  }, {\n    key: \"rawToScatter\",\n    value: function rawToScatter(arrs) {\n      var faceted = [];\n      var counts = {};\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = arrs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var arr = _step2.value;\n          var scatter = [];\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = arr[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var item = _step3.value;\n              item = this.round(item);\n              var y = counts[item] = (counts[item] || 0) + 1;\n              scatter.push({\n                x: item,\n                y: y\n              });\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n\n          faceted.push(scatter);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return faceted;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this.chart.data.datasets[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var dataset = _step4.value;\n          dataset.data = [];\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"setDataFromRaw\",\n    value: function setDataFromRaw(rawDataArrays) {\n      var scatterArrays = this.rawToScatter(rawDataArrays);\n\n      for (var idx = 0; idx < rawDataArrays.length; idx++) {\n        this.chart.data.datasets[idx].data = scatterArrays[idx];\n      }\n\n      var max = 1;\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = scatterArrays[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var dataset = _step5.value;\n          var _iteratorNormalCompletion6 = true;\n          var _didIteratorError6 = false;\n          var _iteratorError6 = undefined;\n\n          try {\n            for (var _iterator6 = dataset[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n              var item = _step6.value;\n              max = Math.max(max, item.y);\n            }\n          } catch (err) {\n            _didIteratorError6 = true;\n            _iteratorError6 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                _iterator6.return();\n              }\n            } finally {\n              if (_didIteratorError6) {\n                throw _iteratorError6;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      this.chart.options.scales.yAxes[0].ticks.stepSize = Math.pow(10, Math.floor(Math.log10(max)));\n    }\n  }, {\n    key: \"setScale\",\n    value: function setScale(start, end) {\n      this.chart.options.scales.xAxes[0].ticks.min = start;\n      this.chart.options.scales.xAxes[0].ticks.max = end;\n    }\n    /**\n     * Attempts to scale y dimension to make the dots stack directly on top of\n     * each other. If there is not enough space in the chart to do so, the y will\n     * scale to contain all the dots, squishing them to clip into each other.\n     * When there are many dots, this makes the stack look like a vertical bar.\n     */\n\n  }, {\n    key: \"scaleToStackDots\",\n    value: function scaleToStackDots() {\n      // TODO(matthewmerrill): memoize getMax with a dirty flag\n      var max = 1;\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = this.chart.data.datasets[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var dataset = _step7.value;\n          var _iteratorNormalCompletion8 = true;\n          var _didIteratorError8 = false;\n          var _iteratorError8 = undefined;\n\n          try {\n            for (var _iterator8 = dataset.data[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n              var item = _step8.value;\n              max = Math.max(max, item.y);\n            }\n          } catch (err) {\n            _didIteratorError8 = true;\n            _iteratorError8 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n                _iterator8.return();\n              }\n            } finally {\n              if (_didIteratorError8) {\n                throw _iteratorError8;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      var _this$chart$chartArea = this.chart.chartArea,\n          top = _this$chart$chartArea.top,\n          bottom = _this$chart$chartArea.bottom;\n      var chartHeight = bottom - top;\n      var pointRadius = this.chart.data.datasets[0].pointRadius;\n      this.chart.options.scales.yAxes[0].ticks.max = Math.max(max, this.chart.options.scales.yAxes[0].ticks.min + chartHeight / pointRadius * 0.5);\n    }\n  }, {\n    key: \"updateLabelName\",\n    value: function updateLabelName(datasetIndex, labelName) {\n      this.datasets[datasetIndex].label = labelName;\n    }\n  }, {\n    key: \"changeDotAppearance\",\n    value: function changeDotAppearance(pointRadius, stepSize) {\n      this.chart.data.datasets.forEach(function (x) {\n        x.pointRadius = pointRadius;\n      });\n      this.chart.options.scales.yAxes.forEach(function (x) {\n        x.ticks.stepSize = stepSize;\n      });\n    }\n  }, {\n    key: \"setAnimationDuration\",\n    value: function setAnimationDuration(duration) {\n      this.chart.options.animation.duration = duration;\n    }\n  }]);\n\n  return StackedDotChart;\n}();\n\n\n\n//# sourceURL=webpack:///./dist/en/util/stackeddotchart.js?");

/***/ }),

/***/ "./dist/en/util/translate.js":
/*!***********************************!*\
  !*** ./dist/en/util/translate.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar translation = {\n  \"about\": {\n    \"contact\": \"Contact\",\n    \"content1\": \"Statistical Analysis Visualizations for Introductory Statistics (SAVIS) was conceived as part of a collaborative research project on statistical education between the Department of Mathematics and Statistics at California State University Sacramento (CSUS) and the School of Mathematics of the Universidad Autónoma de Yucatán (UADY). SAVIS is an educational tool to help to intuitively understand concepts of tests of statistical hypotheses and confidence intervals using visualizations based on resampling and randomization techniques. SAVIS has an online and a stand-alone version (both freely available) in English and Spanish.\",\n    \"content2\": \"SAVIS was created in the Spring of 2019  and extended in the Spring of 2020 by the following graduating seniors from the Department of Computer Science at CSUS under the direction of Rafael E. Diaz Escamilla, a professor in the Department of Mathematics and Statistics at CSUS:\",\n    \"contributors\": \"Contributors\",\n    \"title\": \"About\"\n  },\n  \"download\": {\n    \"title\": \"Download\"\n  },\n  \"home\": {\n    \"title\": \"Home\"\n  },\n  \"oneMean\": {\n    \"InInterval\": \"Values in Interval\",\n    \"NotInInterval\": \"Values not in Interval\",\n    \"Samples\": \"Samples\",\n    \"build\": \"Build\",\n    \"chartTitle2\": \"Generate Hypothetical Population\",\n    \"chartTitle4\": \"Sampling Distribution of Means\",\n    \"ci\": \"Confidence Level\",\n    \"cititle\": \"One Mean Confidence Interval\",\n    \"drawSample\": \"Draw Sample\",\n    \"enterData\": \"Enter Data:\",\n    \"errorNoPopulation\": \"No population data\",\n    \"errorNotEnoughElements\": \"Sample exceeds population\",\n    \"extremeSamples\": \"Sample means at least as extreme as\",\n    \"hypotheticalPopulation\": \"Hypothetical Population\",\n    \"id\": \"ID\",\n    \"increaseData\": \"Increase data\",\n    \"loadData\": \"Load Data\",\n    \"lower\": \"Lower Bound:\",\n    \"mean1\": \"Mean:\",\n    \"mean2\": \"Mean\",\n    \"meanOfsamplesMeans\": \"Mean of sample means:\",\n    \"mostRecentDraw\": \"Most Recent Draw\",\n    \"noData\": \"NaN\",\n    \"noOfSample\": \"# of samples\",\n    \"oneTailLeft\": \"One Tail Left\",\n    \"oneTailRight\": \"One Tail Right\",\n    \"original\": \"Original Dataset\",\n    \"originalSize\": \"Size n:\",\n    \"pleaseSelect\": \"Type of Test\",\n    \"proportion\": \"Proportion:\",\n    \"reset\": \"Reset\",\n    \"runSim\": \"Run Simulation\",\n    \"sample\": \"Sample XXX\",\n    \"sampleMeans\": \"sample means\",\n    \"sampleNo\": \"#\",\n    \"sampleSize\": \"Sample size:\",\n    \"samples\": \"samples\",\n    \"sd1\": \"Standard Deviation:\",\n    \"selectData\": \"Select Sample Data\",\n    \"shiftMean\": \"Shift mean\",\n    \"std\": \"Standard Deviation\",\n    \"textAreaPlaceHolder\": \"Please enter data or drop columns from cvs file here (no column titles - see sample data in drop down menu)\",\n    \"times\": \"times\",\n    \"title\": \"One Mean Hypothesis Testing\",\n    \"totalNoOfSamples\": \"Total # of samples:\",\n    \"totalSamples\": \"Total # samples:\",\n    \"twoTail\": \"Two Tails\",\n    \"upload\": \"Upload Data File\",\n    \"upper\": \"Upper Bound:\",\n    \"value\": \"Value\"\n  },\n  \"oneProportion\": {\n    \"InInterval\": \"Values in Interval\",\n    \"NotInInterval\": \"Values not in Interval\",\n    \"Samples\": \"Samples\",\n    \"addSamples\": \"Add samples\",\n    \"alertAtLeastOne\": \"You must have at least one successes and failures\",\n    \"binomial\": \"Binomial Prediction\",\n    \"build\": \"Build\",\n    \"ci\": \"Confidence Level\",\n    \"cititle\": \"One Proportion Confidence Interval\",\n    \"data\": \"Data\",\n    \"drawSamples\": \"Draw Samples\",\n    \"enterData\": \"Enter Data:\",\n    \"failures\": \"Failures\",\n    \"inc\": \"Increase By\",\n    \"incrementWarning\": \"Please increment the data for group\",\n    \"incrementZeroWarning\": \"Increase by factor must be greater than zero\",\n    \"loadData\": \"Load Data\",\n    \"lower\": \"Lower Bound:\",\n    \"maxHead\": \"Max # of head:\",\n    \"meanNoOfHeads\": \"Mean # of heads:\",\n    \"meanOfSampleDiff\": \"Mean of Sample Proportions\",\n    \"minHead\": \"Min # of heads:\",\n    \"mostRecentDraw\": \"Most Recent Draw\",\n    \"noData\": \"NaN\",\n    \"noOfHeads\": \"# of heads in\",\n    \"noOfSamples\": \"# of samples\",\n    \"noOfSims\": \"# of Simulations\",\n    \"probHeads\": \"Probability of Heads p:\",\n    \"propOfRandom\": \"Proportion of Successes of Most Recent Draw\",\n    \"proportion\": \"Proportion:\",\n    \"proportion1\": \"Proportion of Successes\",\n    \"remark1\": \"1. Double click the graph to zoom in/out if # of tosses >= 50.\",\n    \"remark2\": \"2. Click the legend to hide/show corresponding info in graph.\",\n    \"remarkTitle\": \"Remarks:\",\n    \"reset\": \"Reset\",\n    \"runSims\": \"Run Simulations\",\n    \"samplesInterval\": \"# of samples in interval:\",\n    \"selectInterval\": \"Select interval for # of heads in\",\n    \"selected\": \"Selected\",\n    \"standardDeviation\": \"Standard Deviation\",\n    \"std\": \"Standard Deviation:\",\n    \"subTitle3\": \"Sampling Distribution of Proportions\",\n    \"successes\": \"Successes\",\n    \"title\": \"One Proportion Hypothesis Testing\",\n    \"tosses1\": \"Tosses:\",\n    \"tosses2\": \"tosses:\",\n    \"totalSamples\": \"Total samples:\",\n    \"upper\": \"Upper Bound:\"\n  },\n  \"site\": {\n    \"title\": \"Statistical Analysis Visualizations for Introductory Statistics\"\n  },\n  \"tailChart\": {\n    \"oneTailLeft\": \"One Tail Left\",\n    \"oneTailRight\": \"One Tail Right\",\n    \"pleaseSelect\": \"Type of Test\",\n    \"twoTail\": \"Two Tails\"\n  },\n  \"twoMean\": {\n    \"InInterval\": \"Values in Interval\",\n    \"NotInInterval\": \"Values not in Interval\",\n    \"Samples\": \"Samples\",\n    \"alertAtLeastOne\": \"Group 1 and Group 2 must both have at least one element.\",\n    \"build\": \"Build\",\n    \"ci\": \"Confidence Level\",\n    \"cititle\": \"Two Means Confidence Interval\",\n    \"diffOfMean\": \"Difference of Means (Mean 1 - Mean 2):\",\n    \"diffOfSampleMean\": \"Difference of Means (Randomized Samples):\",\n    \"differences\": \"Differences\",\n    \"enterData\": \"Enter Data\",\n    \"gp1Mean\": \"Mean 1 (Group 1):\",\n    \"gp1SD\": \"Standard Deviation (Group 1):\",\n    \"gp2Mean\": \"Mean 2 (Group 2):\",\n    \"gp2SD\": \"Standard Deviation (Group 2):\",\n    \"group1\": \"Group 1\",\n    \"group2\": \"Group 2\",\n    \"inc1\": \"Increase By (Group 1)\",\n    \"inc2\": \"Increase By (Group 2)\",\n    \"incrementWarning\": \"Please increment the data for group\",\n    \"incrementZeroWarning\": \"Increase by factor must be greater than zero\",\n    \"loadData\": \"Load Data\",\n    \"lower\": \"Lower Bound:\",\n    \"meanSampleDiff\": \"Mean of Sample Differences:\",\n    \"mostRecentDraw\": \"Most Recent Draw\",\n    \"noData\": \"NaN\",\n    \"numSelected\": \"# of Extreme Differences:\",\n    \"numSim\": \"# of Simulations\",\n    \"oriDiffOfMean\": \"Original Dataset Difference of Means:\",\n    \"placeholder\": \"Enter or Drop CSV with first column as group number (1 or 2) and second column as variable. No colunm names (see sample data in drop down menu)\",\n    \"proportionSelcted\": \"Proportion of Extreme Differences\",\n    \"randomMean1\": \"Mean of Randomized Sample to Group 1:\",\n    \"randomMean2\": \"Mean of Randomized Sample to Group 2:\",\n    \"randomSD1\": \"Standard Deviation of Randomized Sample to Group 1:\",\n    \"randomSD2\": \"Standard Deviation of Randomized Sample to Group 2:\",\n    \"reset\": \"Reset\",\n    \"runSim\": \"Run Simulation\",\n    \"runSims\": \"Run Simulations\",\n    \"selectAllExtreme\": \"Select differences at least as extreme as\",\n    \"selectData\": \"Select Sample Data\",\n    \"size1\": \"Size n (Group 1):\",\n    \"size2\": \"Size n (Group 2):\",\n    \"stdSampleDiff\": \"Standard Deviation:\",\n    \"subTitle3\": \"Sampling Distribution of Difference of Means\",\n    \"title\": \"Two Means Hypothesis Testing\",\n    \"totalSamples\": \"Total # samples:\",\n    \"upload\": \"Upload Data File\",\n    \"upper\": \"Upper Bound:\"\n  },\n  \"twoProportions\": {\n    \"InInterval\": \"Values in Interval\",\n    \"NotInInterval\": \"Values not in Interval\",\n    \"alertAtLeastOne\": \"Group A and Group B must both have at least one element.\",\n    \"build\": \"Build\",\n    \"ci\": \"Confidence Level\",\n    \"cititle\": \"Two Proportions Confidence Interval\",\n    \"diffOfProp\": \"Difference of Proportions\",\n    \"differences\": \"Differences\",\n    \"enterData\": \"Enter Data:\",\n    \"failures\": \"Failures\",\n    \"groupA\": \"Group A\",\n    \"groupB\": \"Group B\",\n    \"inc\": \"Increase By\",\n    \"incrementWarning\": \"Please increment the data for group\",\n    \"incrementZeroWarning\": \"Increase by factor must be greater than zero\",\n    \"loadData\": \"Load Data\",\n    \"lower\": \"Lower Bound:\",\n    \"meanOfSampleDiff\": \"Mean of Sample Differences:\",\n    \"mostRecentDraw\": \"Most Recent Draw\",\n    \"noData\": \"NaN\",\n    \"noOfSelected\": \"# Extreme Differences:\",\n    \"noOfSims\": \"# of Simulations\",\n    \"noSim\": \"N/A\",\n    \"oriDatasetDiff\": \"Difference of Proportions in Original Data:\",\n    \"propGroupA\": \"Proportion of Succeses in Group A\",\n    \"propGroupB\": \"Proportion of Successes in Group B\",\n    \"propOfRandomA\": \"Proportion of Successes Randomized to Group A\",\n    \"propOfRandomB\": \"Proportion of Successes Randomized to Group B\",\n    \"propSamplesSelected\": \"Proportion Extreme Differences:\",\n    \"runSims\": \"Run Simulations\",\n    \"selectAllExtreme\": \"Select differences as extreme as:\",\n    \"std\": \"Standard Deviation:\",\n    \"subTitle3\": \"Sampling Distribution of Difference of Proportions\",\n    \"successes\": \"Successes\",\n    \"title\": \"Two Proportions Hypothesis Testing\",\n    \"totalSamples\": \"Total # Samples:\",\n    \"upper\": \"Upper Bound:\"\n  },\n  \"userManual\": {\n    \"title\": \"User Manual\"\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (translation);\n\n//# sourceURL=webpack:///./dist/en/util/translate.js?");

/***/ })

/******/ });